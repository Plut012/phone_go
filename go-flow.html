<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Flow</title>
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#1a1210; font-family:sans-serif; height:100vh; overflow:hidden; }
#input-screen { padding:20px; height:100%; display:flex; flex-direction:column; }
#input-screen h1 { color:#e8dcc4; font-size:22px; margin-bottom:10px; }
#input-screen p { color:#a89080; font-size:13px; margin-bottom:15px; }
#sgf-input { flex:1; background:#262018; border:1px solid #3d3028; color:#e8dcc4; font-family:monospace; font-size:11px; padding:12px; resize:none; }
#sgf-input::placeholder { color:#6d5a4a; }
#load-btn { margin-top:12px; padding:14px; background:#c9a868; color:#1a1210; border:none; font-size:15px; }
#board-screen { display:none; height:100%; position:relative; }
#board-container { height:100%; display:flex; align-items:center; justify-content:center; padding:10px; }
canvas { max-width:100%; max-height:100%; }
#info { position:absolute; top:10px; right:14px; color:#a89080; font-size:14px; }
#back { position:absolute; top:10px; left:14px; color:#a89080; font-size:22px; background:none; border:none; }
#home-screen { padding:20px; height:100%; display:flex; flex-direction:column; justify-content:center; }
#home-screen h1 { color:#e8dcc4; font-size:28px; margin-bottom:30px; text-align:center; }
.menu-btn { padding:16px; margin:8px 0; background:#c9a868; color:#1a1210; border:none; font-size:16px; border-radius:4px; }
#bot-screen { display:none; padding:20px; height:100%; overflow-y:auto; }
#bot-screen h2 { color:#e8dcc4; font-size:20px; margin-bottom:15px; }
#bot-screen button { width:100%; padding:14px; margin:12px 0; background:#c9a868; color:#1a1210; border:none; font-size:15px; border-radius:4px; cursor:pointer; }
#status { color:#a89080; font-size:13px; margin:10px 0; min-height:20px; }
.board-interactive canvas { cursor:pointer; }
</style>
</head>
<body>

<div id="home-screen">
  <h1>Flow</h1>
  <button class="menu-btn" onclick="showScreen('bot-screen')">Play Bot</button>
  <button class="menu-btn" onclick="showScreen('input-screen')">Review SGF</button>
</div>

<div id="input-screen" style="display:none;">
  <h1>Flow</h1>
  <p>Paste SGF. Tap right/left to navigate.</p>
  <textarea id="sgf-input" placeholder="(;GM[1]..."></textarea>
  <button id="load-btn">Load Game</button>
</div>

<div id="bot-screen">
  <h2>Play Bot</h2>
  <div id="bot-selector" style="margin-bottom:15px;">
    <label style="color:#a89080; font-size:14px; display:block; margin-bottom:5px;">Opponent:</label>
    <select id="bot-select" style="width:100%; padding:10px; background:#262018; border:1px solid #3d3028; color:#e8dcc4; font-size:14px; border-radius:4px;">
      <option value="amybot-beginner">Amy Bot Beginner (~25k) - Basic</option>
      <option value="amybot-ddk">Amy Bot DDK (~15k) - Solid</option>
      <option value="amybot-sdk" selected>Amy Bot SDK (~5k) - Tactical</option>
      <option value="nightly-katago">NightlyKataGo (Very Strong) - Fighting</option>
      <option value="kata-bot">KataGo (Strong) - Modern</option>
    </select>
  </div>
  <div id="board-size-selector" style="margin-bottom:15px;">
    <label style="color:#a89080; font-size:14px; display:block; margin-bottom:5px;">Board Size:</label>
    <select id="board-size" style="width:100%; padding:10px; background:#262018; border:1px solid #3d3028; color:#e8dcc4; font-size:14px; border-radius:4px;">
      <option value="9">9x9</option>
      <option value="13">13x13</option>
      <option value="19">19x19</option>
    </select>
  </div>
  <div id="color-selector" style="margin-bottom:15px;">
    <label style="color:#a89080; font-size:14px; display:block; margin-bottom:5px;">Your Color:</label>
    <select id="player-color" style="width:100%; padding:10px; background:#262018; border:1px solid #3d3028; color:#e8dcc4; font-size:14px; border-radius:4px;">
      <option value="black">Black</option>
      <option value="white">White</option>
    </select>
  </div>
  <div id="theme-selector" style="margin-bottom:15px;">
    <label style="color:#a89080; font-size:14px; display:block; margin-bottom:5px;">Theme:</label>
    <select id="board-theme" style="width:100%; padding:10px; background:#262018; border:1px solid #3d3028; color:#e8dcc4; font-size:14px; border-radius:4px;">
      <option value="classic">Classic Wood</option>
      <option value="landscape">Ink Landscape</option>
    </select>
  </div>
  <button id="start-game-btn" onclick="startBotGame()">Start Game</button>
  <div id="status"></div>
  <div id="game-board" style="display:none;">
    <div style="display:flex; gap:10px; margin:0 auto 10px; max-width:300px;">
      <button id="pass-btn" style="flex:1; background:none; border:1px solid #6d5a4a; color:#a89080; padding:8px 20px; font-size:13px; border-radius:3px; cursor:pointer;" onclick="passMove()">Pass</button>
      <button id="resign-btn" style="flex:1; background:none; border:1px solid #6d5a4a; color:#a89080; padding:8px 20px; font-size:13px; border-radius:3px; cursor:pointer;" onclick="resignGame()">Resign</button>
      <button id="return-menu-btn" style="display:none; flex:1; background:#c9a868; border:none; color:#1a1210; padding:8px 20px; font-size:13px; border-radius:3px; cursor:pointer;" onclick="returnToMenu()">New Game</button>
    </div>
    <div id="board-container-bot" style="height:400px; display:flex; align-items:center; justify-content:center;">
      <canvas id="canvas-bot" class="board-interactive"></canvas>
    </div>
    <div id="game-info" style="color:#a89080; margin-top:10px; text-align:center;"></div>
    <button id="submit-move-btn" style="display:none; width:100%; max-width:300px; margin:15px auto 0; padding:20px; background:#c9a868; color:#1a1210; border:none; font-size:16px; border-radius:8px; cursor:pointer; font-weight:500; box-shadow:0 2px 8px rgba(201,168,104,0.3);" onclick="submitMove()"></button>
  </div>
</div>

<div id="board-screen">
  <button id="back">&larr;</button>
  <div id="board-container"><canvas id="canvas"></canvas></div>
  <div id="info"></div>
</div>

<script>
// ============================================================================
// Bot Play Mode
// ============================================================================

const PROXY = 'http://localhost:5000';

// Bot IDs and their characteristics
// Note: Amy bots are officially maintained and always available
const BOTS = {
  'amybot-beginner': { id: 605979, name: 'Amy Bot Beginner', rank: '~25k', style: 'Basic' },
  'amybot-ddk': { id: 431859, name: 'Amy Bot DDK', rank: '~15k', style: 'Solid' },
  'amybot-sdk': { id: 424928, name: 'Amy Bot SDK', rank: '~5k', style: 'Tactical' },
  'nightly-katago': { id: 530672, name: 'NightlyKataGo', rank: 'Very Strong', style: 'Fighting' },
  'kata-bot': { id: 592684, name: 'KataGo', rank: 'Strong', style: 'Modern' }
};

const DEFAULT_BOT = 'amybot-sdk'; // Good for developing fighting skills

var botGame = {
  socket: null,
  playerId: null,
  username: null,
  gameId: null,
  gameAuth: null,
  board: null,
  boardSize: 9,
  myColor: null,
  currentTurn: null,
  phase: 'play',
  previewMove: null,  // {x, y} for move being previewed
  pendingMove: false,  // Waiting for server confirmation
  theme: 'classic',   // 'classic' or 'landscape'
  noise: null,        // Noise generator for landscape theme
  inkField: null,     // Ink diffusion field
  inkBuffer: null,    // Buffer for diffusion
  gameSeed: null      // Seed for noise generation
};

// ============================================================================
// Noise Generator for Landscape Theme
// ============================================================================

class Noise {
  constructor(seed) {
    this.p = new Uint8Array(512);
    let s = seed | 0;
    for (let i = 0; i < 256; i++) {
      s = (s * 16807 + 7) & 0x7fffffff;
      this.p[i] = s & 255;
    }
    for (let i = 0; i < 256; i++) this.p[i + 256] = this.p[i];
  }
  fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
  lerp(a, b, t) { return a + t * (b - a); }
  grad(h, x, y) {
    const g = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
    const v = g[h & 7];
    return v[0] * x + v[1] * y;
  }
  get(x, y) {
    const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
    const xf = x - Math.floor(x), yf = y - Math.floor(y);
    const u = this.fade(xf), v = this.fade(yf);
    const p = this.p;
    const a = p[X] + Y, b = p[X + 1] + Y;
    return this.lerp(
      this.lerp(this.grad(p[a], xf, yf), this.grad(p[b], xf - 1, yf), u),
      this.lerp(this.grad(p[a + 1], xf, yf - 1), this.grad(p[b + 1], xf - 1, yf - 1), u),
      v
    );
  }
  octaves(x, y, n, persistence) {
    let val = 0, amp = 1, freq = 1, max = 0;
    for (let i = 0; i < n; i++) {
      val += this.get(x * freq, y * freq) * amp;
      max += amp;
      amp *= persistence;
      freq *= 2;
    }
    return val / max;
  }
}

// ============================================================================
// Ink Field for Landscape Theme
// ============================================================================

const INK_RES = 128;

function initInkField(size) {
  botGame.inkField = new Float32Array(INK_RES * INK_RES);
  botGame.inkBuffer = new Float32Array(INK_RES * INK_RES);
}

function dropInk(bx, by, color) {
  const ix = (bx / (botGame.boardSize - 1)) * (INK_RES - 1);
  const iy = (by / (botGame.boardSize - 1)) * (INK_RES - 1);
  const radius = INK_RES * 0.08;
  const intensity = color === 1 ? 0.6 : -0.6;

  for (let y = 0; y < INK_RES; y++) {
    for (let x = 0; x < INK_RES; x++) {
      const dx = x - ix, dy = y - iy;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < radius) {
        const falloff = Math.pow(1 - d / radius, 2);
        botGame.inkField[y * INK_RES + x] += intensity * falloff;
      }
    }
  }
}

function diffuseInk() {
  for (let i = 0; i < 3; i++) {
    for (let y = 1; y < INK_RES - 1; y++) {
      for (let x = 1; x < INK_RES - 1; x++) {
        const idx = y * INK_RES + x;
        botGame.inkBuffer[idx] = (
          botGame.inkField[idx] * 0.6 +
          botGame.inkField[idx - 1] * 0.1 +
          botGame.inkField[idx + 1] * 0.1 +
          botGame.inkField[(y - 1) * INK_RES + x] * 0.1 +
          botGame.inkField[(y + 1) * INK_RES + x] * 0.1
        );
      }
    }
    [botGame.inkField, botGame.inkBuffer] = [botGame.inkBuffer, botGame.inkField];
  }
}

function showScreen(screenId) {
  document.getElementById('home-screen').style.display = 'none';
  document.getElementById('input-screen').style.display = 'none';
  document.getElementById('bot-screen').style.display = 'none';
  document.getElementById('board-screen').style.display = 'none';
  document.getElementById(screenId).style.display = screenId === 'input-screen' ? 'flex' : 'block';
}

function setStatus(msg) {
  document.getElementById('status').textContent = msg;
}

function setGameInfo(msg) {
  document.getElementById('game-info').textContent = msg;
}

async function apiCall(endpoint, method = 'GET', body = null) {
  const opts = { method, headers: {} };
  if (body) {
    opts.headers['Content-Type'] = 'application/json';
    opts.body = JSON.stringify(body);
  }
  const resp = await fetch(PROXY + endpoint, opts);
  return resp.json();
}

async function startBotGame() {
  try {
    setStatus('Getting config...');

    // Get config (proxy already authenticated via .env)
    const config = await apiCall('/api/config');
    botGame.playerId = config.user.id;
    botGame.username = config.user.username;
    const chatAuth = config.chat_auth;
    const notificationAuth = config.notification_auth;

    // Connect WebSocket
    setStatus('Connecting to OGS...');
    botGame.socket = io(PROXY);

    botGame.socket.on('connect', () => {
      setStatus('Connected! Authenticating...');
      botGame.socket.emit('connect_ogs');
    });

    botGame.socket.on('ogs_connected', () => {
      setStatus('Authenticated! Challenging bot...');

      // Authenticate
      botGame.socket.emit('authenticate', {
        player_id: botGame.playerId,
        username: botGame.username,
        auth: chatAuth
      });

      botGame.socket.emit('notification/connect', {
        player_id: botGame.playerId,
        username: botGame.username,
        auth: notificationAuth
      });

      botGame.socket.emit('chat/connect', {
        player_id: botGame.playerId,
        username: botGame.username,
        auth: chatAuth
      });

      // Start keep-alive
      setInterval(() => {
        botGame.socket.emit('net/ping', { client: Date.now() });
      }, 20000);

      // Challenge bot
      challengeBot();
    });

    botGame.socket.on('error', (err) => {
      setStatus('Error: ' + (err.message || JSON.stringify(err)));
      console.error('Socket error:', err);
    });

    botGame.socket.on('ogs_disconnected', () => {
      setStatus('Disconnected from OGS');
    });

    // Listen for game events
    botGame.socket.onAny((event, data) => {
      console.log('Event:', event, data);
      handleGameEvent(event, data);
    });

  } catch (err) {
    setStatus('Error: ' + err.message);
    console.error(err);
  }
}

async function challengeBot() {
  try {
    // Get selected bot, board size, color, and theme
    const selectedBot = document.getElementById('bot-select').value;
    const botId = BOTS[selectedBot].id;
    botGame.boardSize = parseInt(document.getElementById('board-size').value);
    const selectedColor = document.getElementById('player-color').value;
    botGame.theme = document.getElementById('board-theme').value;

    // Initialize landscape theme resources if selected
    if (botGame.theme === 'landscape') {
      botGame.gameSeed = Date.now();
      botGame.noise = new Noise(botGame.gameSeed);
      initInkField(botGame.boardSize);
    }

    const challenge = {
      game: {
        name: "Sparring",
        rules: "chinese",
        ranked: false,
        width: botGame.boardSize,
        height: botGame.boardSize,
        handicap: 0,
        komi_auto: "automatic",
        disable_analysis: false,
        initial_state: null,
        private: false,
        time_control: "fischer",
        time_control_parameters: {
          system: "fischer",
          time_increment: 30,
          initial_time: 300,
          max_time: 600
        }
      },
      challenger_color: selectedColor,
      min_ranking: -1000,
      max_ranking: 1000
    };

    const result = await apiCall('/api/challenge/' + botId, 'POST', challenge);
    botGame.gameId = result.game;

    setStatus('Game created! Waiting for bot...');

    // Get game details for auth token
    const gameData = await apiCall('/api/game/' + botGame.gameId);
    botGame.gameAuth = gameData.auth;

    // Determine our color
    console.log('Game data players:', gameData.players);
    console.log('My player ID:', botGame.playerId, 'type:', typeof botGame.playerId);

    const blackId = gameData.players?.black?.id;
    const whiteId = gameData.players?.white?.id;
    console.log('Black ID:', blackId, 'type:', typeof blackId);
    console.log('White ID:', whiteId, 'type:', typeof whiteId);

    // Use == for loose comparison in case of type mismatch
    if (blackId == botGame.playerId) {
      botGame.myColor = 'black';
    } else if (whiteId == botGame.playerId) {
      botGame.myColor = 'white';
    } else {
      console.error('Could not determine player color! Player ID not found in game data');
      botGame.myColor = 'black'; // Default fallback
    }
    console.log('My color determined:', botGame.myColor);

    // Connect to game
    botGame.socket.emit('game/connect', {
      player_id: botGame.playerId,
      game_id: botGame.gameId,
      chat: false
    });

  } catch (err) {
    setStatus('Challenge error: ' + err.message);
  }
}

function handleGameEvent(event, data) {
  // Game data received
  if (event === `game/${botGame.gameId}/gamedata`) {
    const gameData = data;

    // Initial game setup
    if (gameData.phase === 'play' && !botGame.board) {
      setStatus('Game started!');
      initBotBoard(gameData);
      document.getElementById('start-game-btn').style.display = 'none';
      document.getElementById('bot-selector').style.display = 'none';
      document.getElementById('board-size-selector').style.display = 'none';
      document.getElementById('color-selector').style.display = 'none';
      document.getElementById('theme-selector').style.display = 'none';
      document.getElementById('game-board').style.display = 'block';
      drawBotBoard();
      updateTurnInfo();
    }

    // Game finished with outcome
    if (gameData.phase === 'finished' && gameData.outcome) {
      const outcome = gameData.outcome;
      let scoreText = 'Game Over\n';

      if (outcome === 'Resignation') {
        scoreText = 'Game Over - Resignation';
      } else if (outcome === 'Timeout') {
        scoreText = 'Game Over - Timeout';
      } else {
        // Parse score (format: "B+12.5" or "W+R")
        scoreText = `Game Over\n${outcome}`;
      }

      setGameInfo(scoreText);

      // Show return button
      document.getElementById('pass-btn').style.display = 'none';
      document.getElementById('resign-btn').style.display = 'none';
      document.getElementById('return-menu-btn').style.display = 'block';
    }
  }

  // Move received from server (includes our own moves echoed back)
  if (event === `game/${botGame.gameId}/move`) {
    const moveArray = data.move || [];
    const [x, y, time] = moveArray;

    console.log('Move received:', { x, y, time, currentTurn: botGame.currentTurn, data });

    // Process move (pass if x,y are negative)
    if (x >= 0 && y >= 0 && botGame.board[y] && botGame.board[y][x] !== undefined) {
      // Color is determined by whose turn it currently is (before the move)
      const color = botGame.currentTurn;
      console.log(`Placing ${color === 1 ? 'black' : 'white'} stone at (${x}, ${y})`);

      botGame.board[y][x] = color;
      removeCapturesBot(x, y, color);

      // Drop ink for landscape theme
      if (botGame.theme === 'landscape') {
        dropInk(x, y, color);
        diffuseInk();
      }
    }

    // Switch turn
    botGame.currentTurn = botGame.currentTurn === 1 ? 2 : 1;

    // Clear pending state
    botGame.pendingMove = false;

    drawBotBoard();
    updateTurnInfo();
  }

  // Phase changes
  if (event === `game/${botGame.gameId}/phase`) {
    botGame.phase = data;

    if (data === 'stone removal') {
      setGameInfo('Scoring...');
      // Auto-accept stone removal recommendation
      botGame.socket.emit('game/removed_stones/accept', {
        auth: botGame.gameAuth,
        game_id: botGame.gameId,
        player_id: botGame.playerId,
        stones: '',
        strict_seki_mode: false
      });
    }

    if (data === 'finished') {
      // Score will be shown via gamedata event
      setGameInfo('Game finished!');
    }
  }

  // Clock updates
  if (event === `game/${botGame.gameId}/clock`) {
    // Could display time here
  }
}

function initBotBoard(gameData) {
  console.log('Initializing board with gameData:', gameData);

  // Create board of dynamic size
  const size = botGame.boardSize;
  botGame.board = [];
  for (let i = 0; i < size; i++) {
    botGame.board[i] = [];
    for (let j = 0; j < size; j++) {
      botGame.board[i][j] = 0;
    }
  }

  // Store player IDs to determine colors
  const blackPlayerId = gameData.players?.black?.id;
  const whitePlayerId = gameData.players?.white?.id;
  console.log('Players:', { black: blackPlayerId, white: whitePlayerId, myId: botGame.playerId, myColor: botGame.myColor });

  // Replay existing moves
  if (gameData.moves && gameData.moves.length > 0) {
    console.log(`Replaying ${gameData.moves.length} existing moves`);
    gameData.moves.forEach((moveData, idx) => {
      const [x, y] = moveData;
      if (x >= 0 && y >= 0) {
        const color = (idx % 2 === 0) ? 1 : 2; // Black plays first
        console.log(`  Move ${idx}: ${color === 1 ? 'black' : 'white'} at (${x}, ${y})`);
        botGame.board[y][x] = color;
        removeCapturesBot(x, y, color);

        // Drop ink for landscape theme
        if (botGame.theme === 'landscape') {
          dropInk(x, y, color);
        }
      }
    });

    // Diffuse all ink at once for landscape theme
    if (botGame.theme === 'landscape') {
      diffuseInk();
    }
  }

  // Set current turn based on move count
  // Black (1) always goes first, white (2) goes second
  const moveCount = gameData.moves?.length || 0;
  botGame.currentTurn = (moveCount % 2 === 0) ? 1 : 2;

  console.log(`Move count: ${moveCount}, current turn: ${botGame.currentTurn === 1 ? 'black' : 'white'}`);
  console.log('initBotBoard complete:', {
    boardSize: botGame.boardSize,
    currentTurn: botGame.currentTurn,
    myColor: botGame.myColor,
    moveCount: moveCount
  });
}

function updateTurnInfo() {
  const myTurn = (botGame.currentTurn === 1 && botGame.myColor === 'black') ||
                 (botGame.currentTurn === 2 && botGame.myColor === 'white');
  const colorName = botGame.currentTurn === 1 ? 'Black' : 'White';
  setGameInfo(myTurn ? `Your turn (${colorName})` : `Bot's turn (${colorName})`);
}

// Main draw dispatcher
function drawBotBoard() {
  if (botGame.theme === 'landscape') {
    drawBotBoardLandscape();
  } else {
    drawBotBoardClassic();
  }
}

// Classic theme rendering
function drawBotBoardClassic() {
  const canvas = document.getElementById('canvas-bot');
  const ctx = canvas.getContext('2d');
  const container = document.getElementById('board-container-bot');

  const boardSize = botGame.boardSize;
  const displaySize = Math.min(container.clientWidth, container.clientHeight) - 20;
  const dpr = window.devicePixelRatio || 1;

  canvas.width = displaySize * dpr;
  canvas.height = displaySize * dpr;
  canvas.style.width = displaySize + 'px';
  canvas.style.height = displaySize + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  const cs = displaySize / (boardSize + 1);
  const m = cs;

  // Board background
  ctx.fillStyle = '#7d5c4a';
  ctx.fillRect(0, 0, displaySize, displaySize);

  // Grid lines
  ctx.strokeStyle = '#1a1210';
  ctx.lineWidth = 1;
  for (let i = 0; i < boardSize; i++) {
    ctx.beginPath();
    ctx.moveTo(m + i * cs, m);
    ctx.lineTo(m + i * cs, m + (boardSize - 1) * cs);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(m, m + i * cs);
    ctx.lineTo(m + (boardSize - 1) * cs, m + i * cs);
    ctx.stroke();
  }

  // Star points
  ctx.fillStyle = '#1a1210';
  if (boardSize === 9) {
    [2, 6].forEach(i => {
      [2, 6].forEach(j => {
        ctx.beginPath();
        ctx.arc(m + i * cs, m + j * cs, cs * 0.1, 0, 6.3);
        ctx.fill();
      });
    });
    ctx.beginPath();
    ctx.arc(m + 4 * cs, m + 4 * cs, cs * 0.1, 0, 6.3);
    ctx.fill();
  } else if (boardSize === 13) {
    [3, 9].forEach(i => {
      [3, 9].forEach(j => {
        ctx.beginPath();
        ctx.arc(m + i * cs, m + j * cs, cs * 0.1, 0, 6.3);
        ctx.fill();
      });
    });
    ctx.beginPath();
    ctx.arc(m + 6 * cs, m + 6 * cs, cs * 0.1, 0, 6.3);
    ctx.fill();
  } else if (boardSize === 19) {
    [3, 9, 15].forEach(i => {
      [3, 9, 15].forEach(j => {
        ctx.beginPath();
        ctx.arc(m + i * cs, m + j * cs, cs * 0.1, 0, 6.3);
        ctx.fill();
      });
    });
  }

  // Draw stones
  for (let y = 0; y < boardSize; y++) {
    for (let x = 0; x < boardSize; x++) {
      const stone = botGame.board[y][x];
      if (stone) {
        const cx = m + x * cs;
        const cy = m + y * cs;
        const r = cs * 0.45;

        // Shadow
        ctx.beginPath();
        ctx.arc(cx + 1.5, cy + 1.5, r, 0, 6.3);
        ctx.fillStyle = 'rgba(15,10,8,0.4)';
        ctx.fill();

        // Stone
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, 6.3);
        ctx.fillStyle = stone === 1 ? '#4a1e28' : '#e0a870';
        ctx.fill();
      }
    }
  }

  // Draw preview move (semi-transparent)
  if (botGame.previewMove) {
    const px = botGame.previewMove.x;
    const py = botGame.previewMove.y;
    const cx = m + px * cs;
    const cy = m + py * cs;
    const r = cs * 0.45;

    // Determine preview color based on whose turn it is
    const myTurn = (botGame.currentTurn === 1 && botGame.myColor === 'black') ||
                   (botGame.currentTurn === 2 && botGame.myColor === 'white');
    if (myTurn) {
      const previewColor = botGame.currentTurn === 1 ? '#4a1e28' : '#e0a870';

      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, 6.3);
      ctx.fillStyle = previewColor;
      ctx.globalAlpha = 0.5;
      ctx.fill();
      ctx.globalAlpha = 1.0;
    }
  }
}

// Landscape theme rendering
function drawBotBoardLandscape() {
  const canvas = document.getElementById('canvas-bot');
  const ctx = canvas.getContext('2d');
  const container = document.getElementById('board-container-bot');

  const boardSize = botGame.boardSize;
  const displaySize = Math.min(container.clientWidth, container.clientHeight) - 20;
  const dpr = window.devicePixelRatio || 1;

  canvas.width = displaySize * dpr;
  canvas.height = displaySize * dpr;
  canvas.style.width = displaySize + 'px';
  canvas.style.height = displaySize + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  const cs = displaySize / (boardSize + 1);
  const m = cs;

  // Render landscape background
  renderLandscape(ctx, displaySize);

  // Grid lines
  ctx.strokeStyle = 'rgba(60, 45, 30, 0.35)';
  ctx.lineWidth = 0.8;
  for (let i = 0; i < boardSize; i++) {
    const pos = m + i * cs;
    ctx.beginPath();
    ctx.moveTo(m, pos);
    ctx.lineTo(displaySize - m, pos);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(pos, m);
    ctx.lineTo(pos, displaySize - m);
    ctx.stroke();
  }

  // Star points
  const starPoints = boardSize === 19
    ? [[3,3],[3,9],[3,15],[9,3],[9,9],[9,15],[15,3],[15,9],[15,15]]
    : boardSize === 13
    ? [[3,3],[3,9],[6,6],[9,3],[9,9]]
    : [[2,2],[2,6],[4,4],[6,2],[6,6]];

  ctx.fillStyle = 'rgba(60, 45, 30, 0.45)';
  for (const [x, y] of starPoints) {
    ctx.beginPath();
    ctx.arc(m + x * cs, m + y * cs, 2.5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Draw stones
  for (let y = 0; y < boardSize; y++) {
    for (let x = 0; x < boardSize; x++) {
      const stone = botGame.board[y][x];
      if (!stone) continue;

      const cx = m + x * cs;
      const cy = m + y * cs;
      const r = cs * 0.45;

      // Shadow
      ctx.beginPath();
      ctx.arc(cx + 1.2, cy + 1.5, r, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fill();

      // Stone with gradient
      const grad = ctx.createRadialGradient(
        cx - r * 0.3, cy - r * 0.3, r * 0.1,
        cx, cy, r
      );

      if (stone === 1) {
        grad.addColorStop(0, '#4a4540');
        grad.addColorStop(0.7, '#2a2725');
        grad.addColorStop(1, '#1a1815');
      } else {
        grad.addColorStop(0, '#f5f0e8');
        grad.addColorStop(0.5, '#e8e0d4');
        grad.addColorStop(1, '#d8cfc0');
      }

      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.fill();
    }
  }

  // Draw preview move (semi-transparent, no landscape re-render for performance)
  if (botGame.previewMove) {
    const px = botGame.previewMove.x;
    const py = botGame.previewMove.y;
    const cx = m + px * cs;
    const cy = m + py * cs;
    const r = cs * 0.45;

    const myTurn = (botGame.currentTurn === 1 && botGame.myColor === 'black') ||
                   (botGame.currentTurn === 2 && botGame.myColor === 'white');
    if (myTurn) {
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fillStyle = botGame.currentTurn === 1 ? 'rgba(30,28,25,0.3)' : 'rgba(240,235,225,0.3)';
      ctx.fill();
    }
  }
}

function landscapeColor(noiseVal, inkVal) {
  const base = noiseVal * 0.5 + 0.5; // 0..1

  // Warm wood palette
  const r0 = 180, g0 = 148, b0 = 110; // light wood
  const r1 = 140, g1 = 108, b1 = 72;  // dark wood grain

  let t = base;
  let r = r0 + (r1 - r0) * t;
  let g = g0 + (g1 - g0) * t;
  let b = b0 + (b1 - b0) * t;

  // Ink influence
  const ink = Math.max(-1, Math.min(1, inkVal));
  if (ink > 0) {
    // Black stone ink: darker
    r -= ink * 45;
    g -= ink * 40;
    b -= ink * 30;
  } else {
    // White stone ink: lighter
    r -= ink * 30;
    g -= ink * 28;
    b -= ink * 20;
  }

  return [
    Math.round(Math.max(0, Math.min(255, r))),
    Math.round(Math.max(0, Math.min(255, g))),
    Math.round(Math.max(0, Math.min(255, b)))
  ];
}

function renderLandscape(ctx, displaySize) {
  const imageData = ctx.createImageData(displaySize, displaySize);
  const data = imageData.data;

  for (let py = 0; py < displaySize; py++) {
    for (let px = 0; px < displaySize; px++) {
      const nx = px / displaySize * 4;
      const ny = py / displaySize * 4;

      // Layered noise for complex grain
      const n1 = botGame.noise.octaves(nx, ny, 5, 0.55);
      const n2 = botGame.noise.octaves(nx * 2.2 + 100, ny * 0.8 + 100, 3, 0.5) * 0.3;
      const noiseVal = n1 + n2;

      // Sample ink field with bilinear interpolation
      const ix = (px / displaySize) * (INK_RES - 1);
      const iy = (py / displaySize) * (INK_RES - 1);
      const x0 = Math.floor(ix), y0 = Math.floor(iy);
      const x1 = Math.min(x0 + 1, INK_RES - 1), y1 = Math.min(y0 + 1, INK_RES - 1);
      const fx = ix - x0, fy = iy - y0;
      const inkVal =
        botGame.inkField[y0 * INK_RES + x0] * (1 - fx) * (1 - fy) +
        botGame.inkField[y0 * INK_RES + x1] * fx * (1 - fy) +
        botGame.inkField[y1 * INK_RES + x0] * (1 - fx) * fy +
        botGame.inkField[y1 * INK_RES + x1] * fx * fy;

      const [r, g, b] = landscapeColor(noiseVal, inkVal);
      const i = (py * displaySize + px) * 4;
      data[i] = r;
      data[i + 1] = g;
      data[i + 2] = b;
      data[i + 3] = 255;
    }
  }
  ctx.putImageData(imageData, 0, 0);
}

function removeCapturesBot(x, y, color) {
  const opp = color === 1 ? 2 : 1;
  const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
  const size = botGame.boardSize;

  dirs.forEach(([dx, dy]) => {
    const nx = x + dx;
    const ny = y + dy;
    if (nx >= 0 && nx < size && ny >= 0 && ny < size && botGame.board[ny][nx] === opp) {
      const group = getGroupBot(nx, ny, opp, {});
      if (group.libs === 0) {
        group.stones.forEach(s => {
          botGame.board[s.y][s.x] = 0;
        });
      }
    }
  });
}

function getGroupBot(x, y, color, visited) {
  const size = botGame.boardSize;
  if (x < 0 || x >= size || y < 0 || y >= size) return { stones: [], libs: 0 };
  const key = x + ',' + y;
  if (visited[key]) return { stones: [], libs: 0 };
  if (botGame.board[y][x] === 0) return { stones: [], libs: 1 };
  if (botGame.board[y][x] !== color) return { stones: [], libs: 0 };

  visited[key] = true;
  let stones = [{x, y}];
  let libs = 0;

  [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx, dy]) => {
    const result = getGroupBot(x + dx, y + dy, color, visited);
    stones = stones.concat(result.stones);
    libs += result.libs;
  });

  return { stones, libs };
}

document.getElementById('canvas-bot').onclick = function(e) {
  console.log('Canvas clicked!', {
    gameId: botGame.gameId,
    phase: botGame.phase,
    pendingMove: botGame.pendingMove,
    currentTurn: botGame.currentTurn,
    myColor: botGame.myColor
  });

  if (!botGame.gameId || botGame.phase !== 'play') {
    console.log('Blocked: no gameId or not in play phase');
    return;
  }
  if (botGame.pendingMove) {
    console.log('Blocked: already pending');
    return;
  }

  // Check if it's our turn
  const myTurn = (botGame.currentTurn === 1 && botGame.myColor === 'black') ||
                 (botGame.currentTurn === 2 && botGame.myColor === 'white');
  console.log('Turn check:', { currentTurn: botGame.currentTurn, myColor: botGame.myColor, myTurn });

  if (!myTurn) {
    console.log('Blocked: not your turn');
    return;
  }

  const canvas = document.getElementById('canvas-bot');
  const rect = canvas.getBoundingClientRect();
  const boardSize = botGame.boardSize;
  const size = rect.width;
  const cs = size / (boardSize + 1);
  const m = cs;

  const x = Math.round((e.clientX - rect.left - m) / cs);
  const y = Math.round((e.clientY - rect.top - m) / cs);

  console.log('Clicked position:', { x, y, boardSize });

  if (x < 0 || x >= boardSize || y < 0 || y >= boardSize) {
    console.log('Blocked: out of bounds');
    return;
  }
  if (botGame.board[y][x] !== 0) {
    console.log('Blocked: spot occupied');
    return;
  }

  // Set preview and show submit button
  console.log('Setting preview and showing button');
  botGame.previewMove = { x, y };
  document.getElementById('submit-move-btn').style.display = 'block';
  drawBotBoard();
};

function submitMove() {
  if (!botGame.previewMove || botGame.pendingMove) return;

  const { x, y } = botGame.previewMove;

  // Mark as pending and hide button
  botGame.pendingMove = true;
  document.getElementById('submit-move-btn').style.display = 'none';

  // Send move
  const moveStr = String.fromCharCode(97 + x) + String.fromCharCode(97 + y);
  botGame.socket.emit('game/move', {
    auth: botGame.gameAuth,
    game_id: botGame.gameId,
    player_id: botGame.playerId,
    move: moveStr
  });

  // Clear preview - we'll only update when server confirms
  botGame.previewMove = null;
  drawBotBoard();
}

function passMove() {
  if (!botGame.gameId || botGame.phase !== 'play') return;
  if (botGame.pendingMove) return; // Already waiting

  // Check if it's our turn
  const myTurn = (botGame.currentTurn === 1 && botGame.myColor === 'black') ||
                 (botGame.currentTurn === 2 && botGame.myColor === 'white');
  if (!myTurn) return;

  // Clear any preview
  botGame.previewMove = null;
  document.getElementById('submit-move-btn').style.display = 'none';

  // Mark as pending
  botGame.pendingMove = true;

  // Send pass move
  botGame.socket.emit('game/move', {
    auth: botGame.gameAuth,
    game_id: botGame.gameId,
    player_id: botGame.playerId,
    move: '..'
  });

  // Don't update board - wait for server confirmation
}

function resignGame() {
  if (!botGame.gameId) return;

  if (confirm('Are you sure you want to resign?')) {
    botGame.socket.emit('game/resign', {
      auth: botGame.gameAuth,
      game_id: botGame.gameId,
      player_id: botGame.playerId
    });

    setGameInfo('Resigned');
    botGame.phase = 'finished';

    // Hide game controls, show return button
    document.getElementById('pass-btn').style.display = 'none';
    document.getElementById('resign-btn').style.display = 'none';
    document.getElementById('return-menu-btn').style.display = 'block';
  }
}

function returnToMenu() {
  // Reset game state
  botGame.gameId = null;
  botGame.phase = 'play';
  botGame.previewMove = null;
  botGame.pendingMove = false;
  botGame.theme = 'classic';
  botGame.noise = null;
  botGame.inkField = null;
  botGame.inkBuffer = null;

  // Reset UI
  document.getElementById('game-board').style.display = 'none';
  document.getElementById('pass-btn').style.display = 'block';
  document.getElementById('resign-btn').style.display = 'block';
  document.getElementById('return-menu-btn').style.display = 'none';
  document.getElementById('start-game-btn').style.display = 'block';
  document.getElementById('bot-selector').style.display = 'block';
  document.getElementById('board-size-selector').style.display = 'block';
  document.getElementById('color-selector').style.display = 'block';
  document.getElementById('theme-selector').style.display = 'block';
  setStatus('Ready to start a new game');
  setGameInfo('');
}

// ============================================================================
// SGF Review Mode (original code)
// ============================================================================

var moves = [];
var move = 0;
var positions = [];
var board = [];
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');

function emptyBoard() {
  var b = [];
  for (var i = 0; i < 19; i++) {
    b[i] = [];
    for (var j = 0; j < 19; j++) b[i][j] = 0;
  }
  return b;
}

function copyBoard(b) {
  var c = [];
  for (var i = 0; i < 19; i++) c[i] = b[i].slice();
  return c;
}

function parseSGF(sgf) {
  var result = [];
  var s = sgf.replace(/\s+/g, '');
  var re = /;([BW])\[([a-s])([a-s])\]/g;
  var m;
  while ((m = re.exec(s)) !== null) {
    var color = m[1] === 'B' ? 1 : 2;
    var x = m[2].charCodeAt(0) - 97;
    var y = m[3].charCodeAt(0) - 97;
    result.push({c: color, x: x, y: y});
  }
  return result;
}

function getGroup(b, x, y, color, visited) {
  if (x < 0 || x > 18 || y < 0 || y > 18) return {stones: [], libs: 0};
  var key = x + ',' + y;
  if (visited[key]) return {stones: [], libs: 0};
  if (b[y][x] === 0) return {stones: [], libs: 1};
  if (b[y][x] !== color) return {stones: [], libs: 0};
  visited[key] = true;
  var stones = [{x: x, y: y}];
  var libs = 0;
  var dirs = [[0,1],[0,-1],[1,0],[-1,0]];
  for (var i = 0; i < 4; i++) {
    var r = getGroup(b, x + dirs[i][0], y + dirs[i][1], color, visited);
    stones = stones.concat(r.stones);
    libs += r.libs;
  }
  return {stones: stones, libs: libs};
}

function removeCaptures(b, x, y, color) {
  var opp = color === 1 ? 2 : 1;
  var dirs = [[0,1],[0,-1],[1,0],[-1,0]];
  for (var i = 0; i < 4; i++) {
    var nx = x + dirs[i][0];
    var ny = y + dirs[i][1];
    if (nx >= 0 && nx < 19 && ny >= 0 && ny < 19 && b[ny][nx] === opp) {
      var g = getGroup(b, nx, ny, opp, {});
      if (g.libs === 0) {
        for (var j = 0; j < g.stones.length; j++) {
          b[g.stones[j].y][g.stones[j].x] = 0;
        }
      }
    }
  }
}

function loadGame(sgf) {
  moves = parseSGF(sgf);
  if (moves.length === 0) { alert('No moves found'); return false; }
  board = emptyBoard();
  positions = [copyBoard(board)];
  for (var i = 0; i < moves.length; i++) {
    board[moves[i].y][moves[i].x] = moves[i].c;
    removeCaptures(board, moves[i].x, moves[i].y, moves[i].c);
    positions.push(copyBoard(board));
  }
  move = 0;
  board = copyBoard(positions[0]);
  return true;
}

function draw() {
  var container = document.getElementById('board-container');
  var w = container.clientWidth - 20;
  var h = container.clientHeight - 20;
  var size = Math.min(w, h);
  if (size < 100) size = 300;
  
  var dpr = window.devicePixelRatio || 1;
  canvas.width = size * dpr;
  canvas.height = size * dpr;
  canvas.style.width = size + 'px';
  canvas.style.height = size + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  
  var cs = size / 20;
  var m = cs;
  
  // Soft clay board
  ctx.fillStyle = '#7d5c4a';
  ctx.fillRect(0, 0, size, size);
  
  // Lines match background
  ctx.strokeStyle = '#1a1210';
  ctx.lineWidth = 1;
  for (var i = 0; i < 19; i++) {
    ctx.beginPath();
    ctx.moveTo(m + i * cs, m);
    ctx.lineTo(m + i * cs, m + 18 * cs);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(m, m + i * cs);
    ctx.lineTo(m + 18 * cs, m + i * cs);
    ctx.stroke();
  }
  
  // Star points
  ctx.fillStyle = '#1a1210';
  var stars = [3, 9, 15];
  for (var i = 0; i < 3; i++) {
    for (var j = 0; j < 3; j++) {
      ctx.beginPath();
      ctx.arc(m + stars[i] * cs, m + stars[j] * cs, cs * 0.1, 0, 6.3);
      ctx.fill();
    }
  }
  
  var lastMove = move > 0 ? moves[move - 1] : null;
  
  for (var y = 0; y < 19; y++) {
    for (var x = 0; x < 19; x++) {
      var stone = board[y][x];
      if (stone) {
        var cx = m + x * cs;
        var cy = m + y * cs;
        var r = cs * 0.45;
        
        // Subtle shadow
        ctx.beginPath();
        ctx.arc(cx + 1.5, cy + 1.5, r, 0, 6.3);
        ctx.fillStyle = 'rgba(15,10,8,0.4)';
        ctx.fill();
        
        // Deep burgundy or warm orange-cream
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, 6.3);
        ctx.fillStyle = stone === 1 ? '#4a1e28' : '#e0a870';
        ctx.fill();
        
        // Last move marker
        if (lastMove && lastMove.x === x && lastMove.y === y) {
          ctx.beginPath();
          ctx.arc(cx, cy, r * 0.3, 0, 6.3);
          ctx.fillStyle = stone === 1 ? 'rgba(224,168,112,0.7)' : 'rgba(74,30,40,0.6)';
          ctx.fill();
        }
      }
    }
  }
  
  document.getElementById('info').textContent = move + ' / ' + moves.length;
}

function next() {
  if (move < moves.length) {
    move++;
    board = copyBoard(positions[move]);
    draw();
  }
}

function prev() {
  if (move > 0) {
    move--;
    board = copyBoard(positions[move]);
    draw();
  }
}

document.getElementById('load-btn').onclick = function() {
  var sgf = document.getElementById('sgf-input').value;
  if (loadGame(sgf)) {
    document.getElementById('input-screen').style.display = 'none';
    document.getElementById('board-screen').style.display = 'block';
    setTimeout(draw, 50);
  }
};

document.getElementById('back').onclick = function() {
  document.getElementById('board-screen').style.display = 'none';
  document.getElementById('input-screen').style.display = 'flex';
};

canvas.onclick = function(e) {
  var rect = canvas.getBoundingClientRect();
  if (e.clientX - rect.left < rect.width / 2) prev();
  else next();
};

var touchX = 0;
canvas.ontouchstart = function(e) { touchX = e.touches[0].clientX; };
canvas.ontouchend = function(e) {
  var dx = e.changedTouches[0].clientX - touchX;
  if (dx > 30) next();
  else if (dx < -30) prev();
};

window.onresize = function() {
  if (document.getElementById('board-screen').style.display === 'block') {
    draw();
  }
};
</script>
</body>
</html>
